{
  "swagger": "2.0",
  "info": {
    "title": "signcoordinatorrpc/signcoordinator.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "SignCoordinator"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string"
        },
        "value": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "signcoordinatorrpcDeriveSharedKeyRequest": {
      "type": "object",
      "properties": {
        "ephemeral_pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The ephemeral public key to use for the DH key derivation."
        },
        "key_loc": {
          "$ref": "#/definitions/signcoordinatorrpcKeyLocator",
          "description": "Deprecated. The optional key locator of the local key that should be used.\nIf this parameter is not set then the node's identity private key will be\nused."
        },
        "key_desc": {
          "$ref": "#/definitions/signcoordinatorrpcKeyDescriptor",
          "description": "A key descriptor describes the key used for performing ECDH. Either a key\nlocator or a raw public key is expected, if neither is supplied, defaults to\nthe node's identity private key."
        }
      },
      "title": "SharedKeyRequest"
    },
    "signcoordinatorrpcDeriveSharedKeyResponse": {
      "type": "object",
      "properties": {
        "shared_key": {
          "type": "string",
          "format": "byte",
          "description": "The shared public key, hashed with sha256."
        }
      },
      "title": "SharedKeyResponse"
    },
    "signcoordinatorrpcKeyDescriptor": {
      "type": "object",
      "properties": {
        "raw_key_bytes": {
          "type": "string",
          "format": "byte",
          "description": "The raw bytes of the key being identified."
        },
        "key_loc": {
          "$ref": "#/definitions/signcoordinatorrpcKeyLocator",
          "description": "The key locator that identifies which key to use for signing."
        }
      }
    },
    "signcoordinatorrpcKeyLocator": {
      "type": "object",
      "properties": {
        "key_family": {
          "type": "integer",
          "format": "int32",
          "description": "The family of key being identified."
        },
        "key_index": {
          "type": "integer",
          "format": "int32",
          "description": "The precise index of the key being identified."
        }
      }
    },
    "signcoordinatorrpcMuSig2CleanupRequest": {
      "type": "object",
      "properties": {
        "session_id": {
          "type": "string",
          "format": "byte",
          "description": "The unique ID of the signing session that should be removed/cleaned up."
        }
      },
      "title": "MuSig2CleanupRequest"
    },
    "signcoordinatorrpcMuSig2CleanupResponse": {
      "type": "object",
      "title": "MuSig2CleanupResponse"
    },
    "signcoordinatorrpcMuSig2CombineSigRequest": {
      "type": "object",
      "properties": {
        "session_id": {
          "type": "string",
          "format": "byte",
          "description": "The unique ID of the signing session to combine the signatures for."
        },
        "other_partial_signatures": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "The list of all other participants' partial signatures to add to the current\nsession."
        }
      },
      "title": "MuSig2CombineSigRequest"
    },
    "signcoordinatorrpcMuSig2CombineSigResponse": {
      "type": "object",
      "properties": {
        "have_all_signatures": {
          "type": "boolean",
          "description": "Indicates whether all partial signatures required to create a final, full\nsignature are known yet. If this is true, then the final_signature field is\nset, otherwise it is empty."
        },
        "final_signature": {
          "type": "string",
          "format": "byte",
          "description": "The final, full signature that is valid for the combined public key."
        }
      },
      "title": "MuSig2CombineSigResponse"
    },
    "signcoordinatorrpcMuSig2CreateSessionRequest": {
      "type": "object",
      "properties": {
        "key_loc": {
          "$ref": "#/definitions/signcoordinatorrpcKeyLocator",
          "description": "The key locator that identifies which key to use for signing."
        },
        "all_signer_pubkeys": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "A list of all public keys (serialized in 32-byte x-only format for v0.4.0\nand 33-byte compressed format for v1.0.0rc2!) participating in the signing\nsession. The list will always be sorted lexicographically internally. This\nmust include the local key which is described by the above key_loc."
        },
        "other_signer_public_nonces": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional list of all public nonces of other signing participants that\nmight already be known."
        },
        "tweaks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/signcoordinatorrpcTweakDesc"
          },
          "description": "A series of optional generic tweaks to be applied to the the aggregated\npublic key."
        },
        "taproot_tweak": {
          "$ref": "#/definitions/signcoordinatorrpcTaprootTweakDesc",
          "description": "An optional taproot specific tweak that must be specified if the MuSig2\ncombined key will be used as the main taproot key of a taproot output\non-chain."
        },
        "version": {
          "$ref": "#/definitions/signcoordinatorrpcMuSig2Version",
          "description": "The mandatory version of the MuSig2 BIP draft to use. This is necessary to\ndifferentiate between the changes that were made to the BIP while this\nexperimental RPC was already released. Some of those changes affect how the\ncombined key and nonces are created."
        },
        "pregenerated_local_nonce": {
          "type": "string",
          "format": "byte",
          "description": "A set of pre generated secret local nonces to use in the musig2 session.\nThis field is optional. This can be useful for protocols that need to send\nnonces ahead of time before the set of signer keys are known. This value\nMUST be 97 bytes and be the concatenation of two CSPRNG generated 32 byte\nvalues and local public key used for signing as specified in the key_loc\nfield."
        }
      },
      "title": "MuSig2SessionRequest"
    },
    "signcoordinatorrpcMuSig2CreateSessionResponse": {
      "type": "object",
      "properties": {
        "session_id": {
          "type": "string",
          "format": "byte",
          "description": "The unique ID that represents this signing session. A session can be used\nfor producing a signature a single time. If the signing fails for any\nreason, a new session with the same participants needs to be created."
        },
        "combined_key": {
          "type": "string",
          "format": "byte",
          "description": "The combined public key (in the 32-byte x-only format) with all tweaks\napplied to it. If a taproot tweak is specified, this corresponds to the\ntaproot key that can be put into the on-chain output."
        },
        "taproot_internal_key": {
          "type": "string",
          "format": "byte",
          "description": "The raw combined public key (in the 32-byte x-only format) before any tweaks\nare applied to it. If a taproot tweak is specified, this corresponds to the\ninternal key that needs to be put into the witness if the script spend path\nis used."
        },
        "local_public_nonces": {
          "type": "string",
          "format": "byte",
          "description": "The two public nonces the local signer uses, combined into a single value\nof 66 bytes. Can be split into the two 33-byte points to get the individual\nnonces."
        },
        "have_all_nonces": {
          "type": "boolean",
          "description": "Indicates whether all nonces required to start the signing process are known\nnow."
        },
        "version": {
          "$ref": "#/definitions/signcoordinatorrpcMuSig2Version",
          "description": "The version of the MuSig2 BIP that was used to create the session."
        }
      },
      "title": "MuSig2SessionResponse"
    },
    "signcoordinatorrpcMuSig2RegisterNoncesRequest": {
      "type": "object",
      "properties": {
        "session_id": {
          "type": "string",
          "format": "byte",
          "description": "The unique ID of the signing session those nonces should be registered with."
        },
        "other_signer_public_nonces": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "A list of all public nonces of other signing participants that should be\nregistered."
        }
      },
      "title": "MuSig2RegisterNoncesRequest"
    },
    "signcoordinatorrpcMuSig2RegisterNoncesResponse": {
      "type": "object",
      "properties": {
        "have_all_nonces": {
          "type": "boolean",
          "description": "Indicates whether all nonces required to start the signing process are known\nnow."
        }
      },
      "title": "MuSig2RegisterNoncesResponse"
    },
    "signcoordinatorrpcMuSig2SignRequest": {
      "type": "object",
      "properties": {
        "session_id": {
          "type": "string",
          "format": "byte",
          "description": "The unique ID of the signing session to use for signing."
        },
        "message_digest": {
          "type": "string",
          "format": "byte",
          "description": "The 32-byte SHA256 digest of the message to sign."
        },
        "cleanup": {
          "type": "boolean",
          "description": "Cleanup indicates that after signing, the session state can be cleaned up,\nsince another participant is going to be responsible for combining the\npartial signatures."
        }
      },
      "title": "MuSig2SignRequest"
    },
    "signcoordinatorrpcMuSig2SignResponse": {
      "type": "object",
      "properties": {
        "local_partial_signature": {
          "type": "string",
          "format": "byte",
          "description": "The partial signature created by the local signer."
        }
      },
      "title": "MuSig2SignResponse"
    },
    "signcoordinatorrpcMuSig2Version": {
      "type": "string",
      "enum": [
        "MUSIG2_VERSION_UNDEFINED",
        "MUSIG2_VERSION_V040",
        "MUSIG2_VERSION_V100RC2"
      ],
      "default": "MUSIG2_VERSION_UNDEFINED",
      "description": " - MUSIG2_VERSION_UNDEFINED: The default value on the RPC is zero for enums so we need to represent an\ninvalid/undefined version by default to make sure clients upgrade their\nsoftware to set the version explicitly.\n - MUSIG2_VERSION_V040: The version of MuSig2 that lnd 0.15.x shipped with, which corresponds to the\nversion v0.4.0 of the MuSig2 BIP draft.\n - MUSIG2_VERSION_V100RC2: The current version of MuSig2 which corresponds to the version v1.0.0rc2 of\nthe MuSig2 BIP draft."
    },
    "signcoordinatorrpcSignCoordinatorResponse": {
      "type": "object",
      "properties": {
        "request_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique ID of the original signcoordinator gRPC request. Useful for\nmapping request to response. For streaming requests, this will be the same\nID for all incoming and outgoing middleware intercept messages of the\n_same_ stream."
        },
        "connectedResponse": {
          "type": "boolean"
        },
        "deriveSharedKeyResponse": {
          "$ref": "#/definitions/signcoordinatorrpcDeriveSharedKeyResponse"
        },
        "signMessageResponse": {
          "$ref": "#/definitions/signcoordinatorrpcSignMessageResponse"
        },
        "muSig2CreateSessionResponse": {
          "$ref": "#/definitions/signcoordinatorrpcMuSig2CreateSessionResponse"
        },
        "muSig2RegisterNoncesResponse": {
          "$ref": "#/definitions/signcoordinatorrpcMuSig2RegisterNoncesResponse"
        },
        "muSig2SignResponse": {
          "$ref": "#/definitions/signcoordinatorrpcMuSig2SignResponse"
        },
        "muSig2CombineSigResponse": {
          "$ref": "#/definitions/signcoordinatorrpcMuSig2CombineSigResponse"
        },
        "muSig2CleanupResponse": {
          "$ref": "#/definitions/signcoordinatorrpcMuSig2CleanupResponse"
        },
        "signPsbtResponse": {
          "$ref": "#/definitions/signcoordinatorrpcSignPsbtResponse"
        },
        "msg_id": {
          "type": "string",
          "format": "uint64",
          "title": "TODO: REMOVE?"
        }
      }
    },
    "signcoordinatorrpcSignMessageRequest": {
      "type": "object",
      "properties": {
        "msg": {
          "type": "string",
          "format": "byte",
          "description": "The message to be signed. When using REST, this field must be encoded as\nbase64."
        },
        "key_loc": {
          "$ref": "#/definitions/signcoordinatorrpcKeyLocator",
          "description": "The key locator that identifies which key to use for signing."
        },
        "double_hash": {
          "type": "boolean",
          "description": "Double-SHA256 hash instead of just the default single round."
        },
        "compact_sig": {
          "type": "boolean",
          "description": "Use the compact (pubkey recoverable) format instead of the raw lnwire\nformat. This option cannot be used with Schnorr signatures."
        },
        "schnorr_sig": {
          "type": "boolean",
          "description": "Use Schnorr signature. This option cannot be used with compact format."
        },
        "schnorr_sig_tap_tweak": {
          "type": "string",
          "format": "byte",
          "title": "The optional Taproot tweak bytes to apply to the private key before creating\na Schnorr signature. The private key is tweaked as described in BIP-341:\nprivKey + h_tapTweak(internalKey || tapTweak)"
        },
        "tag": {
          "type": "string",
          "format": "byte",
          "description": "An optional tag that can be provided when taking a tagged hash of a\nmessage. This option can only be used when schnorr_sig is true."
        }
      },
      "title": "SignMessageReq"
    },
    "signcoordinatorrpcSignMessageResponse": {
      "type": "object",
      "properties": {
        "signature": {
          "type": "string",
          "format": "byte",
          "description": "The signature for the given message in the fixed-size LN wire format."
        }
      },
      "title": "SignMessageResp"
    },
    "signcoordinatorrpcSignPsbtRequest": {
      "type": "object",
      "properties": {
        "funded_psbt": {
          "type": "string",
          "format": "byte",
          "description": "The PSBT that should be signed. The PSBT must contain all required inputs,\noutputs, UTXO data and custom fields required to identify the signing key."
        }
      },
      "title": "Walletkit SignPsbtRequest"
    },
    "signcoordinatorrpcSignPsbtResponse": {
      "type": "object",
      "properties": {
        "signed_psbt": {
          "type": "string",
          "format": "byte",
          "description": "The signed transaction in PSBT format."
        },
        "signed_inputs": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          },
          "description": "The indices of signed inputs."
        }
      },
      "title": "Walletkit SignPsbtResponse"
    },
    "signcoordinatorrpcTaprootTweakDesc": {
      "type": "object",
      "properties": {
        "script_root": {
          "type": "string",
          "format": "byte",
          "description": "The root hash of the tapscript tree if a script path is committed to. If\nthe MuSig2 key put on chain doesn't also commit to a script path (BIP-0086\nkey spend only), then this needs to be empty and the key_spend_only field\nbelow must be set to true. This is required because gRPC cannot\ndifferentiate between a zero-size byte slice and a nil byte slice (both\nwould be serialized the same way). So the extra boolean is required."
        },
        "key_spend_only": {
          "type": "boolean",
          "description": "Indicates that the above script_root is expected to be empty because this\nis a BIP-0086 key spend only commitment where only the internal key is\ncommitted to instead of also including a script root hash."
        }
      }
    },
    "signcoordinatorrpcTweakDesc": {
      "type": "object",
      "properties": {
        "tweak": {
          "type": "string",
          "format": "byte",
          "description": "Tweak is the 32-byte value that will modify the public key."
        },
        "is_x_only": {
          "type": "boolean",
          "description": "Specifies if the target key should be converted to an x-only public key\nbefore tweaking. If true, then the public key will be mapped to an x-only\nkey before the tweaking operation is applied."
        }
      }
    }
  }
}
